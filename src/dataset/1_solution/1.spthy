/*
Ks is a preshared key between A and B
Na is a nonce generated by A
M is a message from A to B

A -> B : Na
B -> A : senc(Na, Ks)
A -> B : senc(M, Ks)

# Failed properties

Freshness of M
lemma Freshness:
"All a b k #i. K(<a, b, k>) @ i ==> not (Ex #j. K(k) @ j & j < i)"
end
*/

theory One
begin

functions: pk/1, sk/1, aenc/2, adec/2

builtins: symmetric-encryption

equations:
    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,
    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1

rule Asymmetric_key_setup:
    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]

rule Publish_public_keys:
    [ !Pk(A, pkA) ] --> [ Out(pkA) ]

rule Symmetric_key_setup:
    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]

rule Init_Knowledge:
        [ !Pk($A, pk(k_A)),
          !Pk($B, pk(k_B)),
          !Sk($A, sk(k_A)),
          !Sk($B, sk(k_B)),
          Fr(~Ks),
          Fr(~M)
        ]
        --[  ]->
        [ St_init_A($A, ~Ks, ~M, sk(k_A), pk(k_A)),
          St_init_B($B, ~Ks, sk(k_B), pk(k_B))
        ]

// ROLE A
rule m1_A:
        [ St_init_A(A, Ks, M, sk(k_A), pk(k_A)),
          Fr(~Na)
        ]
        --[  ]->
        [ Out(~Na),
          St_m1_A(A, Ks, M, ~Na, sk(k_A), pk(k_A))
        ]

rule m2_A:
        [ St_m1_A(A, Ks, M, Na, sk(k_A), pk(k_A)),
          In(senc{Na}Ks)
        ]
        --[  ]->
        [ St_m2_A(A, Ks, M, Na, sk(k_A), pk(k_A))
        ]

rule m3_A:
        [ St_m2_A(A, Ks, M, Na, sk(k_A), pk(k_A))
        ]
        --[  ]->
        [ Out(senc{M}Ks),
          St_m3_A(A, Ks, M, Na, sk(k_A), pk(k_A))
        ]

// ROLE B
rule m1_B:
        [ St_init_B(B, Ks, sk(k_B), pk(k_B)),
          In(Na)
        ]
        --[  ]->
        [ St_m1_B(B, Ks, Na, sk(k_B), pk(k_B))
        ]

rule m2_B:
        [ St_m1_B(B, Ks, Na, sk(k_B), pk(k_B))
        ]
        --[  ]->
        [ Out(senc{Na}Ks),
          St_m2_B(B, Ks, Na, sk(k_B), pk(k_B))
        ]

rule m3_B:
        [ St_m2_B(B, Ks, Na, sk(k_B), pk(k_B)),
          In(senc{M}Ks)
        ]
        --[ Receive(senc{M}Ks) ]->
        [ St_m3_B(B, Ks, M, Na, sk(k_B), pk(k_B))
        ]


lemma execution:
exists-trace
"Ex m #i . Receive(m) @ #i"

lemma freshness:
"All x  #t1 . Fresh(x)@t1 ==>
not (Ex #t2  #t3 . Received(x)@t2 ∧ Received(x)@t3 ∧ t2 < t3)"
end